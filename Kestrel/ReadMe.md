This implements the core framework for implementing and consuming micro services in a message-driven environment.

# Messages
## Structure
A message is a wrapper around a transport-specific message. It is a hierarchical data structure which contains a set of values. These values are normally named for easy access.

The format of the message is an array of bytes, and can therefore be sent across any messaging transport. As a binary format, it takes far less processing resources than exchanging strings.

The message is implemented as an Abstract Data Type called a data frame which represents itself in a fairly self-describing format where each attribute of the instance is named and typed. It is  encoded in its native binary format.

The first octet is unsigned integer (0-255) indicating the length of the name of the field. If non-zero, the given number of octets are read and parsed into a UTF-8 string.

The next byte represents an unsigned integer (0-255) used to indicate the type of the field. If it is a numeric or other fixed type, the appropriate number of bytes are read in. If a variable type is indicated then the next U32 integer (4-bytes) is read as the length of the data. U32 is used to support nesting of frames within frames which can quickly exceed U16 values of 65535 bytes in length.

Each of the supported data types encodes and decodes the bytes according to their relative types. Strings are Latin-1 encoded (ISO-8859-1). Nested data frames are recursively parsed. Primitive numeric types (signed and unsigned) are encoded in network byte order.

The framework will fallback to JSON strings assuming ISO-8859-1 encoding. This allows simpler bus participants to send data to the framework.     

# Protocol

Messages are sent to a group. Consumers on that group receive messages for processing. Responses to messages are in the form of either a positive acknowledgement (ACK) or a negative acknowledgement (NAK). Both ACK and NAK messages can have a text message, a numeric result code, and a payload, or any combination of the three. The payload is used to carry application data between application entities.

Application data is transported in the payload portion of the message. In a request-response exchange, a requester creates a payload and places request information within it. This is usually in the form of a command string in a "CMD" field and zero or more named arguments. The request payload is placed in a Message with a unique identifier in the "MID" field and a name of the message group on which the message is to be set in the "GRP" field. If the requester expects a reply to the request, it may place the name of the group the responder should send messages in the "RPY" (reply group) field. The requester should also place the message type of "RQS" in the "TYP" message field. The message is sent across the transport and routed to consumers. 

When a consumer receives the message, it will contain the message identifier, group name and other delivery details in the message fields. One of the message fields is the "PLD" field which contains the application sepcific message. Service providers use the payload to retrieve the name of the command and any arguments to command processing.

Response messages are generated by taking the reply group name form the "RPY" field and placing it in the "GRP" message field and taking the message identifier from the "MID" field and placing it in the reply identifier field "RID". This allows for correlating the response message with the request message. The responder will then place a new message identifier in the respones under the "MID" field and populate the type of message it is, either ACK for a positive acknowledgement or an NAK for a negative acknowledgement in the message type (TYP) field. any response data will be place in the "PLD" (payload) field and sent to the requester.  

The requester can then listen for any and all responses to request and correlate all responses by the value of the "RID" field of receive messages.

The framework will generate/overwrite the "ENC" encoding field when a message is received to give the receiver an indication as to the type of response to send. The framework will attempt to support the encoding of responses using this field. For example, if the ENC of a message specifies JSON, the framework will serialize the message using JSON formatted strings using ISO-8859-1 encoding. This should allow non-framework components to participate in the exchange by sending and receiving JSON strings at the expense of bandwidth and processing.

# Operations, Administration and Maintenance

## OAM.SERVICE
This is a topic here service heartbeats are sent. This allows components to discover what services are currently running in the system. By correlating the instance identifiers, it is possible to determine how many instances are servicing each channel.  